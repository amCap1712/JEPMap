{"number":408,"issue":"8260510","related":[],"depends":[],"created":"2021/01/27 12:47","release":"18","name":" Simple Web Server","discussion":"net dash dev at openjdk dot java dot net","projectIds":[],"body":"Summary Provide a command-line tool to start a minimal web server that serves static files only. No CGI or servlet-like functionality is available. This tool will be useful for prototyping, ad-hoc coding, and testing purposes, particularly in educational contexts. Goals Offer an out-of-the-box static HTTP file server with easy setup and minimal functionality. Reduce developer activation energy and make the JDK more approachable. Provide a default implementation via the command line together with a small API for programmatic creation and customization. Non-Goals It is not a goal to provide a feature-rich or commercial-grade server. Far better alternatives exist in the form of server frameworks (e.g., Jetty, Netty, and Grizzly) and production servers (e.g., Apache Tomcat, Apache httpd, and NGINX). These full-fledged and performance-optimized technologies take effort to configure, which is exactly what we want to avoid. It is not a goal to provide security features such as authentication, access control, or encryption. The server is intended solely for testing, development, and debugging. Accordingly, its design is explicitly minimal so as to avoid confusion with a full-featured server application. Motivation A common rite of passage for developers is to serve a file on the web, likely a \u201cHello, world!\u201d HTML file. Most computer science curricula introduce students to web development, where local testing servers are commonly used. Developers usually also learn about system administration and web services, other areas where development tools with basic server functionality can come in handy. Educational and informal tasks such as these are where a small out-of-the-box server is desirable. Use cases include: Web development testing, where a local testing server is used to simulate a client-server set up. Web-service or application testing, where static files are used as API stubs in a directory structure that mirrors RESTful URLs and contains dummy data. Informal browsing and sharing of files across systems to, e.g., search a directory on a remote server from your local machine. In all these cases we can, of course, use a web-server framework, but that approach has a high activation energy: We have to look for options, pick one, download it, configure it, and figure out how to use it before we can serve our first request. These steps amount to quite a bit of ceremony, which is a drawback; getting stuck somewhere on the way can be frustrating and might even hinder the further use of Java. A basic web server spun up from the command line or via a few lines of code lets us bypass this ceremony, so that we can instead focus on the task at hand. Python, Ruby, PHP, Erlang, and many other platforms offer out-of-the-box servers run from the command line. This variety of existing alternatives demonstrates a recognized need for this type of tool. Description The Simple Web Server is a command-line tool for serving a single directory hierarchy. It is based on the web server implementation in the com.sun.net.httpserver package that has been included in the JDK since 2006. The package is officially supported, and we extend it with APIs to simplify server creation and enhance request handling. Command-line tool The following command starts the Simple Web Server by running the main class of the jdk.httpserver module: $ java -m jdk.httpserver If startup is successful then the server prints a message to System.out listing the local address and the absolute path of the directory being served. For example: $ java -m jdk.httpserver\nBinding to loopback by default. For all interfaces use \"-b 0.0.0.0\" or \"-b ::\".\nServing /cwd and subdirectories on 127.0.0.1 port 8000\nURL: http://127.0.0.1:8000/ By default, the server runs in the foreground and binds to the loopback address and port 8000. This can be changed with the -b and -p options. For example, to run on port 9000, use: $ java -m jdk.httpserver -p 9000 For example, to bind the Simple Web Server to all interfaces: $ java -m jdk.httpserver -b 0.0.0.0\nServing /cwd and subdirectories on 0.0.0.0 (all interfaces) port 8000\nURL: http://123.456.7.891:8000/ By default, files are served from the current directory. A different directory can be specified with the -d option. Only idempotent HEAD and GET requests are served. Any other requests receive a 501 - Not Implemented or a 405 - Not Allowed response. GET requests are mapped to the directory being served, as follows: If the requested resource is a file, its content is served. If the requested resource is a directory that contains an index file, the content of the index file is served. Otherwise, the names of all files and subdirectories of the directory are listed. Symbolic links and hidden files are not listed or served. The server supports HTTP only. There is no HTTPS support. MIME types are configured automatically. For example, .html files are served as text/html and .java files are served as text/plain. This can be customized via the java.net.URLConnection::getFileNameMap API. By default, every request is logged on the console. The output looks like this: 127.0.0.1 - - [10/Feb/2021:14:34:11 +0000] \"GET /some/subdirectory/ HTTP/1.1\" 200 - Logging output can be changed with the -o option. The default setting is info. The verbose setting additionally includes the request and response headers as well as the absolute path of the requested resource. Once started successfully, the server runs until it is stopped. On Unix platforms, the server can be stopped by sending it a SIGINT signal (Ctrl+C in a terminal window). The -h option displays a help message listing the options. The options follow the guidelines in JEP 293. Options:\n-b, --bind-address    - Address to bind to. Default: 127.0.0.1 or ::1 (loopback).\n                        For all interfaces use \"-b 0.0.0.0\" or \"-b ::\".\n-d, --directory       - Directory to serve. Default: current directory.\n-o, --output          - Output format. none|info|verbose. Default: info.\n-p, --port            - Port to listen on. Default: 8000.\n-h, -?, --help        - Print this help message.\nTo stop the server, press Ctrl + C. API While the command-line tool is useful, what if one wants to use the components of the Simple Web Server (i.e., server, handler, and filter) with existing code, or further customize the behavior of the handler? While some configuration is possible on the command line, a concise and intuitive programmatic solution for creation and customization would improve the utility of the server components. To bridge the gap between the simplicity of the command-line tool and the write-it-yourself approach of the current com.sun.net.httpserver API, we define new APIs for server creation and customized request handling. The new classes are SimpleFileServer, HttpHandlers, and Request, each built on existing classes and interfaces in the com.sun.net.httpserver package: HttpServer, HttpHandler, Filter, and HttpExchange. The SimpleFileServer class supports the creation of a file server, a file-server handler, and an output filter: package com.sun.net.httpserver;\n\npublic final class SimpleFileServer {\n    public static HttpServer createFileServer(InetSocketAddress addr,\n                                              Path rootDirectory,\n                                              OutputLevel outputLevel) {...}\n    public static HttpHandler createFileHandler(Path rootDirectory) {...}\n    public static Filter createOutputFilter(OutputStream out,\n                                            OutputLevel outputLevel) {...}\n    ...\n} With this class, a minimal yet customized server can be started in a few lines of code in jshell: jshell> var server = SimpleFileServer.createFileServer(new InetSocketAddress(8080),\n   ...> Path.of(\"/some/path\"), OutputLevel.VERBOSE);\njshell> server.start() A customized file-server handler can be added to an existing server: jshell> var server = HttpServer.create(new InetSocketAddress(8080),\n   ...> 10, \"/store/\", new SomePutHandler());\njshell> var handler = SimpleFileServer.createFileHandler(Path.of(\"/some/path\"));\njshell> server.createContext(\"/browse/\", handler);\njshell> server.start(); A customized output filter can be added to a server during creation: jshell> var filter = SimpleFileServer.createOutputFilter(System.out,\n   ...> OutputLevel.INFO);\njshell> var server = HttpServer.create(new InetSocketAddress(8080),\n   ...> 10, \"/store/\", new SomePutHandler(), filter);\njshell> server.start(); The last two examples are enabled by new overloaded create methods in the HttpServer and HttpsServer classes: public static HttpServer create(InetSocketAddress addr,\n                                int backlog,\n                                String root,\n                                HttpHandler handler,\n                                Filter... filters) throws IOException {...} Enhanced request handling The core functionality of the Simple Web Server is provided by its handler. To support extending this handler for use with existing code, we introduce a new HttpHandlers class with two static methods for handler creation and customization as well as a new method in the Filter class for adapting a request: package com.sun.net.httpserver;\n\npublic final class HttpHandlers {\n    public static HttpHandler handleOrElse(Predicate<Request> handlerTest,\n                                           HttpHandler handler,\n                                           HttpHandler fallbackHandler) {...}\n    public static HttpHandler of(int statusCode, Headers headers, String body) {...}\n    {...}\n}\n\npublic abstract class Filter {\n    public static Filter adaptRequest(String description,\n                                      UnaryOperator<Request> requestOperator) {...}\n    {...}\n} handleOrElse complements a conditional handler with another handler, while the factory method of lets you create handlers with pre-set response state. The pre-processing filter obtained from adaptRequest can be used to inspect and adapt certain properties of a request before handling it. Use cases for these methods include delegating exchanges based on the request method, creating a \"canned response\" handler that always returns a certain response, or adding a header to all incoming requests. The existing API captures an HTTP request as part of a request-response pair represented by an instance of the HttpExchange class, which describes the full and mutable state of an exchange. Not all of this state is meaningful for handler customization and adaptation. We therefore introduce a simpler Request interface to provide a limited view of the immutable request state: public interface Request {\n    URI getRequestURI();\n    String getRequestMethod();\n    Headers getRequestHeaders();\n    default Request with(String headerName, List<String> headerValues)\n    {...}\n} This enables the straightforward customization of an existing handler, for example: jshell> var h = HttpHandlers.handleOrElse(r -> r.getRequestMethod().equals(\"PUT\"),\n   ...> new SomePutHandler(), new SomeHandler());\njshell> var f = Filter.adaptRequest(\"Add Foo header\", r -> r.with(\"Foo\", List.of(\"Bar\")));\njshell> var s = HttpServer.create(new InetSocketAddress(8080),\n   ...> 10, \"/\", h, f);\njshell> s.start(); Alternatives We considered several API alternatives during prototyping: A new class DelegatingHandler \u2014 Bundle the customization methods in a separate class that implements the HttpHandler interface. We discarded this option since it comes at the cost of introducing a new type without adding more functionality. This new type would also be hard to discover. The HttpHandlers class, on the other hand, uses the pattern of outboarding, where static helper methods or factories of a class are bundled in a new class. The almost-identical name makes it easy to find the class, facilitates the understanding and use of the new API points, and hides the implementation details of delegation. HttpHandler as a service \u2014 Turn HttpHandler into a service and provide an internal file-server handler implementation. The developer could either provide a custom handler or use the default provider. The disadvantage of this approach is that it is more difficult to use and rather elaborate for the small set of functionality we want to provide. Filter instead of HttpHandler \u2014 Use only filters, not handlers, to process the request. Filters are typically pre- or post-processing, meaning they access a request either before or after the handler is invoked, for example for authentication or logging. However, they were not designed to fully replace handlers. Using them in this way would be counter-intuitive and the methods would be harder to find. Testing The core functionality of the command-line tool is provided by the API, so most of our testing effort will focus on the API. The API points can be tested in isolation with unit tests and the existing test framework. We will focus particularly on file-system access and URI sanitization. We will complement the API tests with command and sanity testing of the command-line tool. Risks and Assumptions This simple server is intended for testing, development, and debugging purposes only. Within this scope the general security concerns of servers apply, and will be addressed by following security best practices and thorough testing.","updated":"2021/10/20 08:32","status":"Integrated"}