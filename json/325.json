{"number":325,"issue":"8192963","related":[354],"depends":[],"created":"2017/12/04 08:56","release":"12","name":" Switch Expressions (Preview)","discussion":"amber dash dev at openjdk dot java dot net","projectIds":[],"body":"Summary Extend the switch statement so that it can be used as either a statement or an expression, and that both forms can use either a \"traditional\" or \"simplified\" scoping and control flow behavior. These changes will simplify everyday coding, and also prepare the way for the use of pattern matching (JEP 305) in switch. This is a preview language feature in JDK 12. Please note: this JEP is superseded by JEP 354, which targets JDK 13. Motivation As we prepare to enhance the Java programming language to support pattern matching (JEP 305), several irregularities of the existing switch statement -- which have long been an irritation to users -- become impediments. These include the default control flow behavior (fall through) of switch blocks, the default scoping of switch blocks (the block is treated as one single scope) and that switch works only as a statement, even though it is commonly more natural to express multi-way conditionals as expressions. The current design of Java's switch statement follows closely languages such as C and C++, and supports fall-through semantics by default. Whilst this traditional control flow is often useful for writing low-level code (such as parsers for binary encodings), as switch is used in higher-level contexts, its error-prone nature starts to outweigh its flexibility. For example, in the following code, the many break statements make it unnecessarily verbose, and this visual noise often masks hard to debug errors, where missing break statements mean that accidental fall-through occurs. switch (day) {\n    case MONDAY:\n    case FRIDAY:\n    case SUNDAY:\n        System.out.println(6);\n        break;\n    case TUESDAY:\n        System.out.println(7);\n        break;\n    case THURSDAY:\n    case SATURDAY:\n        System.out.println(8);\n        break;\n    case WEDNESDAY:\n        System.out.println(9);\n        break;\n} We propose to introduce a new form of switch label, written \"case L ->\" to signify that only the code to the right of the label is to be executed if the label is matched. For example, the previous code can now be written: switch (day) {\n    case MONDAY, FRIDAY, SUNDAY -> System.out.println(6);\n    case TUESDAY                -> System.out.println(7);\n    case THURSDAY, SATURDAY     -> System.out.println(8);\n    case WEDNESDAY              -> System.out.println(9);\n} (This example also uses multiple case labels: we propose to support multiple comma-separated labels in a single switch label.) The code to the right of a \"case L ->\" switch label is restricted to be an expression, a block, or (for convenience) a throw statement. This has the pleasing consequence that should an arm introduce a local variable, it must be contained in a block and thus not in scope for any of the other arms in the switch block. This eliminates another annoyance with \"traditional\" switch blocks where the scope of a local variable is the entire switch block. switch (day) {\n    case MONDAY:\n    case TUESDAY:\n        int temp = ...\n        break;\n    case WEDNESDAY:\n    case THURSDAY:\n        int temp2 = ...     // Why can't I call this temp?\n        break;\n    default:\n        int temp3 = ...     // Why can't I call this temp?\n} Many existing switch statements are essentially simulations of switch expressions, where each arm either assigns to a common target variable or returns a value: int numLetters;\nswitch (day) {\n    case MONDAY:\n    case FRIDAY:\n    case SUNDAY:\n        numLetters = 6;\n        break;\n    case TUESDAY:\n        numLetters = 7;\n        break;\n    case THURSDAY:\n    case SATURDAY:\n        numLetters = 8;\n        break;\n    case WEDNESDAY:\n        numLetters = 9;\n        break;\n    default:\n        throw new IllegalStateException(\"Wat: \" + day);\n} Expressing this as a statement is roundabout, repetitive, and error-prone. The author meant to express that we should compute a value of numLetters for each day. It should be possible to say that directly, using a switch expression, which is both clearer and safer: int numLetters = switch (day) {\n    case MONDAY, FRIDAY, SUNDAY -> 6;\n    case TUESDAY                -> 7;\n    case THURSDAY, SATURDAY     -> 8;\n    case WEDNESDAY              -> 9;\n}; In turn, extending switch to support expressions raises some additional needs, such as extending flow analysis (an expression must always compute a value or complete abruptly), and allowing some case arms of a switch expression to throw an exception rather than yield a value. Description In additional to \"traditional\" switch blocks, we propose to add a new \"simplified\" form, with new \"case L ->\" switch labels. If a label is matched, then only the expression or statement to the right of an arrow label is executed; there is no fall through. For example, given the method: static void howMany(int k) {\n    switch (k) {\n        case 1 -> System.out.println(\"one\");\n        case 2 -> System.out.println(\"two\");\n        case 3 -> System.out.println(\"many\");\n    }\n} The following code: howMany(1);\nhowMany(2);\nhowMany(3); results in the following output: one\ntwo\nmany We will extend the switch statement so that it can additionally be used as an expression. In the common case, a switch expression will look like: T result = switch (arg) {\n    case L1 -> e1;\n    case L2 -> e2;\n    default -> e3;\n}; A switch expression is a poly expression; if the target type is known, this type is pushed down into each arm. The type of a switch expression is its target type, if known; if not, a standalone type is computed by combining the types of each case arm. Most switch expressions will have a single expression to the right of the \"case L ->\" switch label. In the event that a full block is needed, we have extended the break statement to take an argument, which becomes the value of the enclosing switch expression. int j = switch (day) {\n    case MONDAY  -> 0;\n    case TUESDAY -> 1;\n    default      -> {\n        int k = day.toString().length();\n        int result = f(k);\n        break result;\n    }\n}; A switch expression can, like a switch statement, also use a \"traditional\" switch block with \"case L:\" switch labels (implying fall-through semantics). In this case values would be yielded using the break with value statement: int result = switch (s) {\n    case \"Foo\": \n        break 1;\n    case \"Bar\":\n        break 2;\n    default:\n        System.out.println(\"Neither Foo nor Bar, hmmm...\");\n        break 0;\n}; The two forms of break (with and without value) are analogous to the two forms of return in methods. Both forms of return terminate the execution of the method immediately; in a non-void method, additionally a value must be provided which is yielded to the invoker of the method. (Ambiguities between the break expression-value and break label forms can be handled relatively easily.) The cases of a switch expression must be exhaustive; for any possible value there must be a matching switch label. In practice this normally means simply that a default clause is required; however, in the case of an enum switch expression that covers all known cases (and eventually, switch expressions over sealed types), a default clause can be inserted by the compiler that indicates that the enum definition has changed between compile-time and runtime. (This is what developers do by hand today, but having the compiler insert it is both less intrusive and likely to have a more descriptive error message than the ones written by hand.) Furthermore, a switch expression must complete normally with a value, or throw an exception. This has a number of consequences. First, the compiler checks that for every switch label, if it is matched then a value can be yielded. int i = switch (day) {\n    case MONDAY -> {\n        System.out.println(\"Monday\"); \n        // ERROR! Block doesn't contain a break with value\n    }\n    default -> 1;\n};\ni = switch (day) {\n    case MONDAY, TUESDAY, WEDNESDAY: \n        break 0;\n    default: \n        System.out.println(\"Second half of the week\");\n        // ERROR! Group doesn't contain a break with value\n}; A further consequence is that the control statements, break, return and continue, cannot jump through a switch expression, such as in the following: z: \n    for (int i = 0; i < MAX_VALUE; ++i) {\n        int k = switch (e) { \n            case 0:  \n                break 1;\n            case 1:\n                break 2;\n            default: \n                continue z; \n                // ERROR! Illegal jump through a switch expression \n        };\n    ...\n    } As a target of opportunity, we may expand switch to support switching on primitive types (and their box types) that have previously been disallowed, such as float, double, and long. Dependencies Pattern Matching (JEP 305) depends on this JEP.","updated":"2021/08/28 00:17","status":"Closed\u2009/\u2009Delivered"}