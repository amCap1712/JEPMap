{"number":292,"issue":"8066046","related":[],"depends":[],"created":"2014/11/27 00:31","release":"9","name":" Implement Selected ECMAScript 6 Features in Nashorn","discussion":"nashorn dash dev at openjdk dot java dot net","projectIds":[],"body":"Summary Implement, in Nashorn, a selected set of the many new features introduced in the 6th edition of ECMA-262, also known as ECMAScript 6, or ES6 for short. Goals Correctly implement a substantial number of ES6 features in Nashorn in JDK 9. Because of the size of this undertaking, we need to deliver ES6 in several steps of which JDK 9 will only be the first. Remaining ES6 features will likely be delivered in JDK 9 update releases and future major JDK releases. Motivation ECMAScript 6 was released in June 2015. No JavaScript engine so far provides complete support for ES6, but the major engines including Google V8, Mozilla Spidermonkey, and JavaScriptCore have recently made major inroads in the implementation of ES6. We started implementing ES6 in Nashorn with JEP 203 (let and const) in JDK 8u40. In order to keep up with the other engines, we plan to add support for a significant subset of the ECMAScript 6 features in JDK 9. Description ECMAScript 6 includes the following new features: Arrow functions: a concise way of defining functions using => syntax Classes: a way to define classes using inheritance, constructors, and methods Enhanced object literals: support for special and computed property keys Template strings: dynamically-evaluated multiline strings Destructuring assignment: assignment binding using object or array syntax Default, rest, and spread parameters: more flexible argument passing let, const, and block scope: block-scoped declaration of variables and constants Iterators and for..of loops: a protocol to iterate over arbitrary objects Generators: a special kind of function to create iterators Unicode: full Unicode support with backwards compatiblilty Modules: language-level support for the definition of modules Module loaders: support for dynamic loading, isolation, and compilation hooks Map, Set, WeakMap, and WeakSet: various new collection classes Proxies: allows creation of objects with special behaviour Symbols: a new kind of unique property key Subclassable built-ins: built-ins such as Array and Date can be subclassed Promises: an API for asynchronous future completion Math, Number, String, and Object APIs: various new functions on built-in objects Binary and octal literals: new forms for numeric literals Reflection API: API for performing meta-programming operations Tail calls: allow recursive code without unbounded stack growth Of these features we already implemented let, const, and block scope in JDK 8u40 as JEP 203. Several other features have been prototyped and should be added to the list of ES6 features supported in the initial release of JDK 9. These include the following items: Template strings let, const, and block scope Iterators and for..of loops Map, Set, WeakMap, and WeakSet Symbols Binary and octal literals Other features have been partially prototyped and their completion seems possible in a limited time frame. These are candidates for inclusion in JDK 9 update releases: Arrow functions Enhanced object literals Destructuring assignment Default, rest, and spread parameters Unicode Subclassable built-ins Promises Proxies Math, Number, String, and Object APIs Reflection API The remaining features are more involved and will likely take longer to implement. While it might be feasible to include some of these in JDK 9 update releases, we are currently targeting them for future major JDK releases. These features are: Classes Generators Modules Module loaders Tail calls ES6 feature implementation notwithstanding, the Nashorn parser in the JDK 9 Nashorn repository already supports the ES6 syntactic changes. Alternatives Instead of the iterative approach proposed here we could choose to ignore ECMAScript 6 for the time being, and instead focus on improving our existing ECMAScript 5 based implementation instead. Alternatively we could try to implement ES6 in a single effort. However, that would prevent us from getting feedback and finding errors early on. Also, the size and number of new features in ES6 makes that approach impractical Not making any effort towards ES6 would be a mistake and deliver the wrong message to users and customers. Testing As part of the work of implementing parts of ES6 we developed a base body of functional tests that will be part of the JEP. Work has also started to run the ES6 version of the official ECMAScript conformance test suite test262. Initial results are encouraging. However, switching from the ES5.1 version of test262 to the ES6 version as our primary test suite is not feasible since many of the tests require a complete ES6 implementation. We will rely on the ES6 version of test262 during the development and integration of this JEP to spot bugs and fill in missing parts. The plan is to switch to the ES6 version as our primary ES6 test suite once we approach full ES6 functionality. Risks and Assumptions The ECMAScript 6 specification has been released and large parts of it have been implemented in various JavaScript engines, so there is no more risk of a moving specification or of ambiguity in the specification text. It is possible that our prioritization of features leaves out some feature that developers demand. The proposed iterative approach, however, ensures delivery of all missing features over time. Dependences There are dependences between various features within ES6, and our order of implementation has been chosen to address the features in order of increasing complexity.","updated":"2017/03/09 13:36","status":"Closed\u2009/\u2009Delivered"}